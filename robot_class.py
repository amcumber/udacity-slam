### ------------------------------------- ###
# Below, is the robot class
#
# This robot lives in 2D, x-y space, and its motion is
# pointed in a random direction, initially.
# It moves in a straight line until it comes close to a wall
# at which point it stops.
#
# For measurements, it  senses the x- and y-distance
# to landmarks. This is different from range and bearing as
# commonly studied in the literature, but this makes it much
# easier to implement the essentials of SLAM without
# cluttered math.
#

import random

from collections import namedtuple
from dataclasses import dataclass
from typing import Protocol
import numpy as np

Landmark: tuple[float, float, int] = namedtuple(
    "Landmark",
    ["x", "y", "index"],
)


class MeasurementStrategy(Protocol):
    """Strategy for sensing"""

    def __call__(
        self,
        robot_pos: tuple[float, float],
        landmark: Landmark,
    ) -> float:
        ...


def euclidean_dist_strategy(
    robot_pos: tuple[float, float],
    landmark: Landmark,
) -> float:
    """
    Measure the euclidean distance from a landmark and the robot without
    noise.

    Parameters
    ----------
    robot_pos : tuple[float, float]
        robot position in (x, y) format
    landmark : Landmark | tuple[float, float, int]
        landmark item - generated by robot class
    """
    land_x, land_y, *_ = landmark
    p_robot = np.array(robot_pos)
    p_land = np.array([land_x, land_y])
    return np.sqrt(((p_robot - p_land) ** 2).sum())


def square_dist_strategy(
    robot_pos: tuple[float, float],
    landmark: Landmark,
) -> float:
    """
    Measure the max manhatten distance from a landmark and the robot without
    noise. (i.e. this measures the maximum x or y value - this does not sum x
    and y as a typical manhatten distance)

    Parameters
    ----------
    robot_pos : tuple[float, float]
        robot position in (x, y) format
    landmark : Landmark | tuple[float, float, int]
        landmark item - generated by robot class
    """
    land_x, land_y, *_ = landmark
    p_robot = np.array(robot_pos)
    p_land = np.array([land_x, land_y])
    return (p_robot - p_land).max()


# the robot class
@dataclass
class robot:
    """
    creates a robot with the specified parameters and initializes
    the location (self.x, self.y) to the center of the world

    Parameters
    ----------
    world_size : float
        size of square world for robot to explore
    measurement_range : float
        range of sensor using measurement_strategy
    motion_noise : float
        amount of noise in motion
    measurement_noise : float
        amount of noise in measurement
    measurement_strategy : MeasurementStrategy
        strategy to measure distance
    """

    world_size: float = 100.0
    measurement_range: float = 30.0
    motion_noise: float = 1.0
    measurement_noise: float = 1.0
    measurement_strategy: MeasurementStrategy = square_dist_strategy

    def __post_init__(self):
        self.x = self.world_size / 2.0
        self.y = self.world_size / 2.0
        self.landmarks = []
        self.num_landmarks = 0

    # returns a positive, random float
    # [ACM] Incorrect - this returns a random float from [-1, 1]
    def rand(self):
        return random.random() * 2.0 - 1.0

    # --------
    # move: attempts to move robot by dx, dy. If outside world
    #       boundary, then the move does nothing and instead returns failure
    #
    def move(self, dx, dy):

        x = self.x + dx + self.rand() * self.motion_noise
        y = self.y + dy + self.rand() * self.motion_noise

        if x < 0.0 or x > self.world_size or y < 0.0 or y > self.world_size:
            return False
        else:
            self.x = x
            self.y = y
            return True

    # --------
    # sense: returns x- and y- distances to landmarks within visibility range
    #        because not all landmarks may be in this range, the list of measurements
    #        is of variable length. Set measurement_range to -1 if you want all
    #        landmarks to be visible at all times
    #

    ## TODO: complete the sense function
    def sense(self):
        """This function does not take in any parameters, instead it references internal variables
        (such as self.landmarks) to measure the distance between the robot and any landmarks
        that the robot can see (that are within its measurement range).
        This function returns a list of landmark indices, and the measured distances (dx, dy)
        between the robot's position and said landmarks.
        This function should account for measurement_noise and measurement_range.
        One item in the returned list should be in the form: [landmark_index, dx, dy].
        """

        measurements = []

        ## TODO: iterate through all of the landmarks in a world

        ## TODO: For each landmark
        ## 1. compute dx and dy, the distances between the robot and the landmark
        ## 2. account for measurement noise by *adding* a noise component to dx and dy
        ##    - The noise component should be a random value between [-1.0, 1.0)*measurement_noise
        ##    - Feel free to use the function self.rand() to help calculate this noise component
        ##    - It may help to reference the `move` function for noise calculation
        ## 3. If either of the distances, dx or dy, fall outside of the internal var, measurement_range
        ##    then we cannot record them; if they do fall in the range, then add them to the measurements list
        ##    as list.append([index, dx, dy]), this format is important for data creation done later
        # [ACM] Engineering Decision - I used the euclidean distance to measure
        #       my landmarks - this may be generate a flaw in the results
        #       compared to other submissions. Consider changing this to a more
        #       rudimentary calculation if problems arise.
        for landmark in self.landmarks:
            # landmark_idx = landmark.index
            dist = self.measurement_strategy((self.x, self.y), landmark)
            measured_r = dist + self.rand() * self.measurement_noise
            if measured_r > self.measurement_range:
                continue
            measurements.append(landmark)

        ## TODO: return the final, complete list of measurements
        return measurements

    # --------
    # make_landmarks:
    # make random landmarks located in the world
    #
    # [ACM] Engineering decision - added named tuple - Landmark and index to
    #       landmarks - this will ease flow of other values as these landmarks
    #       will be passed around.
    def make_landmarks(self, num_landmarks):
        self.landmarks = []
        for i in range(num_landmarks):
            x = round(random.random() * self.world_size)
            y = round(random.random() * self.world_size)
            landmark = Landmark(x, y, i)
            self.landmarks.append(landmark)
        self.num_landmarks = num_landmarks

    # called when print(robot) is called; prints the robot's location
    def __repr__(self):
        return "Robot: [x=%.5f y=%.5f]" % (self.x, self.y)


####### END robot class #######
